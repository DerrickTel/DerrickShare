# JavaScript内存空间图解

## 栈数据结构

栈, 计算机专业的同学可能都有些了解. 讲究的是一个先进后出. 今天我们简单的来过一下.

![1574493233349](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1574493233349.png)

可以想象为只有一个口子的一条路, 这条路. 每次呢只进去一个人.  后面的人进来的, 只有等后面的人出去了, 先进去的才可以出来. 所以就是 **先进后出**

## 堆数据结构

堆数据结构是一种树状结构。它的存取数据的方式与书架和书非常相似。我们只需要知道书的名字就可以直接取出书了，并不需要把上面的书取出来。JSON格式的数据中，我们存储的`key-value`可以是无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

## 队列

队列是一种先进先出（**FIFO**）的数据结构，这是事件循环（Event Loop）的基础结构，事件循环我们有空的话, 可能会讲一下.

![1574493563753](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1574493563753.png)

## 变量的存放

这个问题是一个老生常谈的问题了, 会引发出深拷贝之类的问题.今天我做一个简单的介绍吧.

首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢，**堆**？**栈**？

- 1、基本类型 --> 保存在**栈**内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol(ES6
- 2、引用类型 --> 保存在**堆**内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从**栈中读取内存地址**， 然后再通过地址**找到堆中的值**。对于这种，我们把它叫做按引用访问。
- 画图
- ![1574493741891](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1574493741891.png)



在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去**栈**查找再去**堆**查找。



## 问题时间

```js
var a = 20;
var b = a;
b = 30;

// 这时a的值是多少？
```

```js
var a = { name: 'Derrick' }
var b = a;
b.name = '帅哥';

// 这时a.name的值是多少
```

```js
var a = { name: 'Derrick' }
var b = a;
a = null;

// 这时b的值是多少
```

```js
function foo() {
    foo();
}
foo();

// 会发生什么?
```

ES6语法中的 const 声明一个只读的常量，那为什么下面可以修改const的值？

































- 对于问题1，a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。
- 对于问题2，a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改`b.name`的值后，相应的`a.name`也就发生了改变。
- 对于问题3，首先要说明的是`null`是基本类型，`a = null`之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。
- 下面的递归就会无限制的执行下去，直到超出调用堆栈的实际大小，这个是浏览器定义的。(如果不限制大小的话, 垃圾回收机制执行就要很久影响性能

## 内存空间管理

JavaScript的内存生命周期是

- 1、分配你所需要的内存
- 2、使用分配到的内存
- 3、不需要时将其释放、归还



=>



## 垃圾回收机制

这里只说一下**V8**引擎, 其他有兴趣的话可以自己了解然后*告! 诉! 大! 家!* 

> OK, 言归正传
>

在V8中，将内存分为了新生代（new space）和老生代（old space）。它们特点如下：

- 新生代：对象的存活时间较短。新生对象或只经过一次垃圾回收的对象。
- 老生代：对象存活时间较长。经历过一次或多次垃圾回收的对象。

V8堆的空间等于新生代空间加上老生代空间。我们可以通过 `--max-old-space-size`命令设置老生代空间的最大值，`--max-new-space-size` 命令设置新生代空间的最大值。老生代与新生代的空间大小在程序初始化时设置，一旦生效则不能动态改变。



```swift
node --max-old-space-size=1700 test.js // 单位为 MB
node --max-new-space-size=1024 test.js // 单位为KB
```

默认设置下，64位系统的老生代大小为1400M，32位系统为700M。
 对于新生代，它由两个 `reserved_semispace_size` 组成。每个`reserved_semispace_size` 的大小在不同位数的机器上大小不同。默认设置下，在64位与32位的系统下分别为16MB和8MB。我们将新生代、老生代、`reserved_semispace_size` 空间大小总结如下表。

| 类型 \ 系统位数         | 64位   | 32位  |
| ----------------------- | ------ | ----- |
| 老生代                  | 1400MB | 700MB |
| reserved_semispace_size | 16MB   | 8MB   |
| 新生代                  | 32MB   | 16MB  |

## 回收算法

### Stop The World （全停顿）

在介绍垃圾回收算法之前，我们先了解一下「全停顿」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）。例如，如果一次GC需要50ms，应用逻辑就会暂停50ms。

全停顿的目的，是为了解决应用逻辑与垃圾回收器看到的情况不一致的问题。举个例子，在自助餐厅吃饭，高高兴兴地取完食物回来时，结果发现自己餐具被服务员收走了。这里，服务员好比垃圾回收器，餐具就像是分配的对象，我们就是应用逻辑。在我们看来，只是将餐具临时放在桌上，但是服务员看来觉得你已经不需要使用了，因此就收走了。你与服务员对于同一个事物看到的情况是不一致，导致服务员做了与我们不期望的事情。因此，为避免应用逻辑与垃圾回收器看到的情况不一致，垃圾回收算法在执行时，需要停止应用逻辑。

### Scavenge 算法

新生代中的对象主要通过 Scavenge 算法进行垃圾回收。Scavenge 的具体实现，主要采用了Cheney算法。

![img](https:////upload-images.jianshu.io/upload_images/1674837-104b491d8ee8a352.png?imageMogr2/auto-orient/strip|imageView2/2/w/616/format/webp)

V8堆内存空间示意图

Cheney算法采用复制的方式进行垃圾回收。它将堆内存一分为二，每一部分空间称为 semispace。这两个空间，只有一个空间处于使用中，另一个则处于闲置。使用中的 semispace 称为 「From 空间」，闲置的 semispace 称为 「To 空间」。

过程如下：

1. 从 From 空间分配对象，若 semispace 被分配满，则执行 Scavenge 算法进行垃圾回收。
2. 检查 From 空间的存活对象，若对象存活，则检查对象是否符合晋升条件，若符合条件则晋升到老生代，否则将对象从 From 空间复制到 To 空间。
3. 若对象不存活，则释放不存活对象的空间。
4. 完成复制后，将 From 空间与 To 空间进行角色翻转（flip）。

#### 对象晋升

对象晋升的条件有两个：

1）对象是否经历过Scavenge回收。对象从 From 空间复制 To 空间时，会检查对象的内存地址来判断对象是否已经经过一次Scavenge回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。

2）To 空间的内存使用占比是否超过限制。当对象从From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置为25%的比例的原因是，当完成 Scavenge 回收后，To 空间将翻转成From 空间，继续进行对象内存的分配。若占比过大，将影响后续内存分配。

对象晋升到老生代后，将接受新的垃圾回收算法处理。下图为Scavenge算法中，对象晋升流程图。

![img](https:////upload-images.jianshu.io/upload_images/1674837-e0defff45eb27070.png?imageMogr2/auto-orient/strip|imageView2/2/w/705/format/webp)

晋升流程图

### 小结

Scavenge 算法的缺点是，它的算法机制决定了只能利用一半的内存空间。但是新生代中的对象生存周期短、存活对象少，进行对象复制的成本不是很高，因而非常适合这种场景。

## Mark-Sweep & Mark-Compact

老生代中的对象有两个特点，第一是存活对象多，第二个存活时间长。若在老生代中使用 Scavenge 算法进行垃圾回收，将会导致复制存活对象的效率不高，且还会浪费一半的空间。因而，V8在老生代采用Mark-Sweep 和 Mark-Compact 算法进行垃圾回收。

### Mark-Sweep

Mark-Sweep，是标记清除的意思。它主要分为标记和清除两个阶段。

- 标记阶段，它将遍历堆中所有对象，并对存活的对象进行标记；
- 清除阶段，对未标记对象的空间进行回收。

与 Scavenge 算法不同，Mark-Sweep 不会对内存一分为二，因此不会浪费空间。但是，经历过一次 Mark-Sweep 之后，内存的空间将会变得不连续，这样会对后续内存分配造成问题。比如，当需要分配一个比较大的对象时，没有任何一个碎片内支持分配，这将提前触发一次垃圾回收，尽管这次垃圾回收是没有必要的。

![img](https:////upload-images.jianshu.io/upload_images/1674837-3c8b7082d646545d.png?imageMogr2/auto-orient/strip|imageView2/2/w/565/format/webp)

Mark-Sweep 标记与清理的示意图

### Mark-Compact

为了解决内存碎片的问题，提高对内存的利用，引入了 Mark-Compact （标记整理）算法。Mark-Compact 是在 Mark-Sweep 算法上进行了改进，标记阶段与Mark-Sweep相同，但是对未标记的对象处理方式不同。与Mark-Sweep是对未标记的对象立即进行回收，Mark-Compact则是将存活的对象移动到一边，然后再清理端边界外的内存。

![img](https:////upload-images.jianshu.io/upload_images/1674837-023c7d9f472d8f1b.png?imageMogr2/auto-orient/strip|imageView2/2/w/480/format/webp)

Mark-Compact 算法

### 小结

由于Mark-Compact需要移动对象，所以执行速度上，比Mark-Sweep要慢。所以，V8主要使用Mark-Sweep算法，然后在当空间内存分配不足时，采用Mark-Compact算法。

## Incremental Marking（增量标记）

在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。如下图所示：

![img](https:////upload-images.jianshu.io/upload_images/1674837-3b49f9629c8abf8e.png?imageMogr2/auto-orient/strip|imageView2/2/w/555/format/webp)

增量标记示意图

长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。从2011年起，v8就将「全暂停」标记换成了增量标记。改进后的标记方式，最大停顿时间减少到原来的1/6。

## lazy sweeping（延迟清理）

- 发生在增量标记之后
- 堆确切地知道有多少空间能被释放
- 延迟清理是被允许的，因此页面的清理可以根据需要进行清理
- 当延迟清理完成后，增量标记将重新开始。

# 总结

垃圾回收的原理较为复杂，在理解上需要花费一些功夫。了解GC原理，有助于我们对NodeJS项目进行性能瓶颈定位与调优。文章所描述的算法为V8中使用的基础算法，现代V8引擎对垃圾回收进行了很多改进，比如，在Chrome 64和Node.js v10中V8启用了「并行标记」技术，将标记时间缩短了60%~70%。还有「Parallel Scavenger」技术，它将新生代的垃圾回收时间缩短了20%~50%。

垃圾回收是影响服务性能的因素之一，为了提高服务性能，应尽量减少垃圾回收的次数。

## 补充

**补充**一个知识点，就是闭包中的变量并不保存中栈内存中，而是保存在`堆内存`中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。

`闭包`的简单定义是：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。

OK, 点到为止, 因为我也不大了解, 哈哈